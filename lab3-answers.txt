Lockmanager:
we create structure LockProfile store txn id and lock type, and locksmanager maps the LockProfile.
LockProfile: data type stores Pid.
grantLock():
if tid has the read locks, it will return true.
if tid has the write locks or there is no lock, it will add lock(read) and return true
else if tid cannot add read lock on the pageid, it will return false.
Wait():
For both grant readlock or write lock follow the following behaviors:
Part1: There are four cases of single lock on page:
First, there is only one lock on the page:
Check whether is our own lock. If it is mine and readlock return it.
Second, add new lock for accessing tid and return.
Third, the lock is other's lock. Two condition if it is read lock, add lock and return. The other is the lock is write lock, wait to return
               
Part2: There are four cases of multi lock on page:
1. two locks and belonging same tid(1 read and 1 write)    
2. two locks and both are not belonging tid( 1read and 1 write)
3. lots of locks, one of it is belonging tid.
4. lots of locks, and no one of it is belonging tid.


Deadlock dependent graph design(using in my simpleDB):
From the waitlist in the lockmanager, we can figure out all the lock that the specific tid hold. If it directly or related hold the lock , return the dead lock occur.
Deadlock timeout:
Set up the time for check the deadlock occur, however, if the condition that the two tids hold other's lock, the time out will not solve the problem. 
Therefore, dependency graph will be better than timeout